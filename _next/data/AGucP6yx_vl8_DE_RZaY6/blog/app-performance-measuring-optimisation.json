{"pageProps":{"post":{"title":"App Performance; Measuring & Optimisation","date":"2018-11-05","content":"\nA new client came to us recently with a project that would test our ability on app performance.\n\nThey had a sample iOS app, which loaded a point cloud into a 3D model. They wanted to build a proof of concept app and incorporate this 3D model into it as a nice visual. App performance was important to them.\n\nWe got to work building the app itself. But once we started to integrate the existing 3D model, issues arose. The time it took for the model to load was quite long, nearly 40 seconds and it froze the app at start up. Not a great start for app performance.\n\nObviously this wasn't good enough, so we set about fixing it. With some tweaks to string handling and parsing, we were able to gain a measurable 16X app performance improvement.\n\nThe code the client brought with them was based on this code on [GitHub.](https://github.com/eugeneu/PoindCloudRenderer) It works by reading in a .ply file containing the x,y,z coordinates of points, then forms a scene kit node from these points. The SceneKit node generated in the sample project looks like this:\n\n[![](images/rotate.gif)](https://tapadoo.wpengine.com/wp-content/uploads/2018/08/rotate.gif)\n\nThere are a few downsides to this point cloud loader; it’s slow, it makes assumptions on the data in the .ply file, ignores additional data like normals and colours.\n\nHowever, the model would not always be known ahead of time and this was a short project. We weren’t going to completely change how the 3D models were stored or loaded on such a tight deadline. So, we decided to see if we could improve this existing code.\n\nTo do this we needed to look at some app measurement techniques in order to improve app performance.\n\n## Time to improve app performance\n\nOur first task was to speed up this PointCloudRenderer project.\n\nThe meat of this example is the PointCloud class. On initialisation it reads in a ply file (hard coded name), parses the header, then takes each line of data, splits into three parts, and converts each part to a Floating point number. It gathers these floats in an array of structs representing the points.\n\nNow, we are guessing this is slow, but as the saying goes, you can’t improve what you don’t measure. So before we go fixing anything, let’s first measure its current performance. We’ll also want to see if our changes are making things better as we go.\n\nIt’s a perfect time to use unit tests and Xcode’s measure feature.\n\n## Measuring Initial Loading\n\nThe sample on GitHub ships with a couple of example .ply files, a bunny and a dragon. The bunny only has ~36K points in its data but the dragon has 437,645 points. This is close enough to our clients, which was 532,993 points. We can use the dragon model for our tests as it performed similarly to our client’s model.\n\nFirst, we make a small tweak to the PointCloud class, to allow us to specify the name of the model file to load. Then we write a unit test class, as shown below and run it. The measure test block executes the code 10 times and gives an average.\n\n \n\n[![](images/initial-times.png)](https://tapadoo.wpengine.com/wp-content/uploads/2018/08/initial-times.png)\n\nRunning these new tests a few times on an iPad gives us a baseline to work with. The Dragon is taking 36 seconds to load on average.\n\nWe can also run the app under the Time Profiler to get an idea of what parts of the init method are taking so long.\n\n \n\n[![](images/profile1.png)](https://tapadoo.wpengine.com/wp-content/uploads/2018/08/profile1.png)\n\n[![](images/profile2.png)](https://tapadoo.wpengine.com/wp-content/uploads/2018/08/profile2.png)\n\nHere's the initialization method for PointCloud:\n\n    init(filename: String = \"bun\\_zipper\\_points\") {\n        super.init()\n        \n        self.n = 0\n        var x, y, z : Double\n        (x,y,z) = (0,0,0)\n        \n        // Open file\n        if let path = Bundle.main.path(forResource: filename, ofType: \"ply\") {\n            do {\n                let data = try String(contentsOfFile: path, encoding: .ascii)\n                var myStrings = data.components(separatedBy: \"\\\\n\")\n                \n                // Read header\n                while !myStrings.isEmpty {\n                    let line = myStrings.removeFirst()\n                    if line.hasPrefix(\"element vertex \") {\n                        n = Int(line.components(separatedBy: \" \")\\[2\\])!\n                        continue\n                    }\n                    if line.hasPrefix(\"end\\_header\") {\n                        break\n                    }\n                }\n                \n                pointCloud = Array<SCNVector3>(repeating: SCNVector3(x:0,y:0,z:0), count: n)\n                \n                // Read data\n                for i in 0...(self.n-1) {\n                    let line = myStrings\\[i\\]\n                    x = Double(line.components(separatedBy: \" \")\\[0\\])!\n                    y = Double(line.components(separatedBy: \" \")\\[1\\])!\n                    z = Double(line.components(separatedBy: \" \")\\[2\\])!\n                    \n                    pointCloud\\[i\\].x = Float(x)\n                    pointCloud\\[i\\].y = Float(y)\n                    pointCloud\\[i\\].z = Float(z)\n                }\n                NSLog(\"Point cloud data loaded: %d points\",n)\n            } catch {\n                print(error)\n            }\n        }\n        \n    }\n\nAnd here’s what the ply file looks like:\n\nply\nformat ascii 1.0\ncomment VCGLIB generated\nelement vertex 437645\nproperty float x\nproperty float y\nproperty float z\nelement face 0\nproperty list uchar int vertex\\_indices\nend\\_header\n0.1791272 -0.2087705 -0.2279476\n0.1780086 -0.2087705 -0.2278163\n0.1808354 -0.2088217 -0.2278163\n0.1808354 -0.2087705 -0.2278363\n0.1809296 -0.2087705 -0.2278163\n0.1791272 -0.2070623 -0.227975\n0.1808354 -0.2070623 -0.2281433\n0.1825437 -0.2074703 -0.2278163\n0.1825437 -0.2070623 -0.2279193\n0.1808354 -0.205354 -0.2280911\n\\[....\\]\n\nHopefully it's easy enough to follow.\n\nIt firsts reads the entire file into a String variable. Then it splits the string into lines. Next it reads the start of the .ply file looking for a line containing “element vertex”. This line contains a count of the number of rows of data. Once it knows how many vectors it's going to be creating, it creates an array of vectors with values of 0,0,0. Finally, it loops over the remaining lines to parse the X,Y,Z values for the vector.\n\n## Reading with sscanf\n\nSo let’s get to improving things.\n\nThe profiling above, shows that 95% of the time was used on splitting strings with the components method and creating Doubles.\n\nThe biggest use of these is in the loop that creates our vectors. It’s splitting one string into three strings (three times), then creating Doubles, then creating floats from those doubles, then updating a vector struct. This works. It’s readable and if it was only a couple of uses I wouldn’t mind. But it’s happening half a million times in our example. It's likely to be wasting time and memory creating new strings at the very least.\n\nIf we replace those calls to split the string, we might end up with something quicker. The first thing that comes to mind when I think of reading three floats from a string is the sscanf function from C. But we are coding in swift here. We can call a scanf function, but it’s a bit uglier. It looks like the following.\n\n \n\npointCloud.reserveCapacity(n)\nvar floatBuffer = UnsafeMutablePointer<Float>.allocate(capacity: 3)\n\n// Read data\nfor i in 0...(self.n-1) {\n    \n    let line = myStrings\\[i\\]\n    \n    let vector = withVaList(\\[floatBuffer,floatBuffer.advanced(by: 1),floatBuffer.advanced(by: 2)\\]) { valList -> SCNVector3 in\n        vsscanf(line,\"%f %f %f\", valList)\n        \n        return SCNVector3(x:floatBuffer\\[0\\],y:floatBuffer\\[1\\],z:floatBuffer\\[2\\])\n    }\n    \n    pointCloud.append(vector)\n}\n\n \n\nFirst, we allocate space in our array, and create a buffer for three floats. We will reuse the memory for the floats on each run of the loop, as the creation of the struct will copy their values anyway. Next, we use the withValList function to create a pointer we can pass to the vsscanf function. Once that returns we can now read the three floats from the buffer.\n\nIt runs. The model still looks correct. But is it faster?\n\nThankfully we can just rerun our tests on the same hardware.\n\nThe results are promising:\n\n[![](images/attempt1.png)](https://tapadoo.wpengine.com/wp-content/uploads/2018/08/attempt1.png)\n\nFrom 36 seconds to five seconds.\n\nThis is a welcome improvement. We include this change in our proof of concept app and move on for now.\n\n## Using NSScanner\n\nBut our new solution isn’t great.\n\nLater we get a chance to come back and try to improve things a little more.\n\nWhile it’s faster, it’s also more ugly with the unwieldy UnsafeMutableBuffers and valList pointers that swift makes us use there. Our leap back to C style programming may have been the wrong path to take. What we need is a better way to read numbers from a string.\n\nNSScanner is a Foundation class, which you initialise with a string and can then read number or substrings from it as it moves over the string while skipping the spaces and new lines. It's exactly what we need here. Rewriting our loop again, it now looks like this:\n\npointCloud.reserveCapacity(n)\n\nvar x: Float = 0\nvar y: Float = 0\nvar z: Float = 0\n// Read data\nfor i in 0 ..< n {\n    let scanner = Scanner(string: myStrings\\[i\\])\n    scanner.scanFloat(&x)\n    scanner.scanFloat(&y)\n    scanner.scanFloat(&z)\n    \n    let vector = SCNVector3(x: x , y: y, z: z)\n    pointCloud.append(vector)\n}\n\n \n\nOK, that reads much nicer. In fact, it even reads nicer than the original code.\n\nBut what are the chances it’s faster?\n\nLets run our tests and find out.\n\n[![](images/attempt2.png)](https://tapadoo.wpengine.com/wp-content/uploads/2018/08/attempt2.png)\n\nEven better again. From 36 seconds to three, it’s an order of magnitude better. It’s running in less than a tenth of the time it originally took.\n\nBefore running the test, part of me was expecting a worse performance. This highlights the importance of measuring your improvements as you go. If both code snippets were shown to me and I was asked to choose the fastest, I probably would have chosen the scanf version as it looked closer to C.\n\n## A Single Scanner\n\nThere is still potential here for more improvements. One thing that's still happening in our initialisation function, is excessive string manipulation. The entire file is read into a String initially but then it's split by line into an array of lines. Then we are removing lines from the array as we search for the number of points, until we reach the end of the header.\n\nIf we can cut out these additional strings and the array manipulation we could see further improvements.\n\nWhile there's nothing wrong with handling each line of the header, we aren’t actually using any of them. We are only hunting for one specific value. Also, as we loop over all the remaining lines we are creating a new Scanner for each line.\n\nWhat if we could instead extract the point count from the string without splitting the lines into an array. And then use one scanner for the entire set of vertex data.\n\nWe can find the parts of the header we are interested in using the range and substring methods on String. Substrings in swift do not take up extra memory.\n\nHere is our new init method with these changes:\n\ninit(filename: String = \"bun\\_zipper\\_points\") {\n    super.init()\n    \n    // Open file\n    if let path = Bundle.main.path(forResource: filename, ofType: \"ply\") {\n        do {\n            let data = try String(contentsOfFile: path, encoding: .ascii)\n            \n            //Without a header, we dont know our point count\n            guard let headerEndRange = data.range(of: \"end\\_header\") else {return }\n            \n            //We need to extract the point count from the header. Lets get the header as a substring to work with\n            let headerSubString = data\\[data.startIndex ... headerEndRange.upperBound\\]\n            \n            guard let elementVertexRange = headerSubString.range(of: \"element vertex \") else {return }\n            \n            //This is the substring container the number followed by the rest of the header\n            let vertexCountParialString = headerSubString.suffix(from: elementVertexRange.upperBound)\n            \n            //Find the next line break and create a substring with just the vertex count\n            let vertexEndIndex = vertexCountParialString.index(of: \"\\\\n\") ?? vertexCountParialString.endIndex\n            let vertexCountString = vertexCountParialString\\[..<vertexEndIndex\\]\n            \n            n = Int(vertexCountString) ?? 0\n            \n            pointCloud.reserveCapacity(n)\n            \n            var x: Float = 0\n            var y: Float = 0\n            var z: Float = 0\n            \n            let pointStartIndex = headerEndRange.upperBound\n            \n            let pointDataSubString = data\\[pointStartIndex...\\]\n\n            let dataScanner = Scanner(string: String(pointDataSubString))\n            \n            // Read data\n            for \\_ in 0 ..< n {\n\n                dataScanner.scanFloat(&x)\n                dataScanner.scanFloat(&y)\n                dataScanner.scanFloat(&z)\n                \n                //bunny model for example has extra data for normals and color. lets ignore anything but the first 3 floats for now by skipping the rest of the line\n                dataScanner.scanUpToCharacters(from: CharacterSet.newlines, into: nil)\n                \n                let vector = SCNVector3(x: x , y: y, z: z)\n                pointCloud.append(vector)\n            }\n            NSLog(\"Point cloud data loaded: %d points\", n)\n        } catch {\n            print(error)\n        }\n    }\n    \n}\n\nWe create a substring for the header, which is more efficient to work with than splitting the string. Then we find the range of the element vertex text we were previously searching for. Once we find that, we can extract the rest of the line and convert it to an Int for our point count. Next, we get the substring containing just the lines of data we need to parse and create a single Scanner that we use in our data parsing loop.\n\nJust hunting for one value in the header isn’t great but it’s all we need. A better ply parser might correctly scan the full header here to determine exactly how many properties to read on each data line and the type of data. But for our proof of concept app we don’t need that, so we skip straight to the values we are interested in.\n\nOnce again, our tests can reveal if we are heading in the right direction or not:\n\n[![](images/attempt3.png)](https://tapadoo.wpengine.com/wp-content/uploads/2018/08/attempt3.png)\n\nThe dragon is down to 2.2 seconds, a further improvement.\n\nSo, with some refactoring of string handling and parsing and some XCTests to help us measure and repeatedly test, we’ve taken the parsing of the dragon sample file from 36 seconds, to 2.2 seconds.\n\n94% better.\n\nOver 16 times faster.\n\nIts tempting to keep going - there’s undoubtedly more savings to be had but this will do for now.\n\nThe original code can be found on [GitHub](https://github.com/eugeneu/PoindCloudRenderer), it was published with a GPL License. A version with the final improvements shown here can be found here : [https://github.com/Tapadoo/PoindCloudRenderer](https://github.com/Tapadoo/PoindCloudRenderer)\n\nYou can also [get in touch](https://tapadoo.wpengine.com/contact/) with us if you need help with developing your app.\n\nJason Connery\n\nLead iOS Developer\n","postImage":"https://cdn-bhcgp.nitrocdn.com/lQsUIlYWTGkhjqgYKmLJkHSBczAwGDPM/assets/static/optimized/rev-f8d7f54/wp-content/uploads/2018/08/Untitled-design.png.webp","categories":["development"]}},"__N_SSG":true}