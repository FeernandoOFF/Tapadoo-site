{"pageProps":{"post":{"title":"Swift JSON Date Formatting","date":"2019-07-29","content":"\nConfused by fractional components appearing in your JSON when using unix timestamps?\n\nSee the custom formatters below for a way to get back to integers if that's what you need for your API\n\nJSON is the de facto way of sending and receiving data from APIs these days. And for iOS developers, Swift has made things easier in recent years with the introduction of Codable. Codable is a way to quickly encode and decode objects to and from JSON. The defaults are pretty good, and the options like key decoding strategy to auto convert from snake case to camel case has been a blessing.\n\nHowever, one place where the defaults seem oddly incorrect is Date properties. The default JSON date format output is not very helpful. Take the following playground for example.\n\n```\nimport UIKit\n\n/////////////////////////////////////////////////////////////\n\nlet event = Event(name: \"Test Event\", widgetCount: 10, timestamp: Date())\nprint(event)\nprintJson(event)\n\n/////////////////////////////////////////////////////////////\n\nstruct Event: Codable {\n\n    let name: String\n    let widgetCount: Int\n    let timestamp: Date\n\n}\n\nextension Event: CustomDebugStringConvertible {\n    var debugDescription: String {\n        return \"[\\(timestamp)] \\(name)\"\n    }\n}\n\n\nfunc printJson<T: Encodable>(_ obj: T) throws {\n    let enc = JSONEncoder()\n    enc.outputFormatting = [.prettyPrinted , .sortedKeys]\n\n    let jsonData = try enc.encode(obj)\n    let jsonString = String(data: jsonData, encoding: .utf8)\n\n    print(jsonString!)\n}\n```\n\nThe output is the following, a debug print out and the json print out:\n\n```\n[2019-04-24 16:06:09 +0000] Test Event\n{\n  \"name\" : \"Test Event\",\n  \"timestamp\" : 577814769.81546402,\n  \"widgetCount\" : 10\n}\n```\n\nThe JSON date format for a `Date` got the value of `577814769.81546402`. This almost looks like a unix epoch timestamp, but if you put it into an online converter it'll come out as 04/23/1988 @ 4:06pm.\n\nIt's not a unix timestamp. It's actually using a different reference date - 2001 instead of 1970. This might be fine for Foundations internals, CoreData, etc. But in all my years of communicating with APIs of varying degrees, I've never once seen a Remote API Spec that used that as a reference date.\n\n## Changing The Default Format\n\nIf you need to use a different format for only a single property, you may need to implement a custom `encode(to encoder: Encoder)` function, or use an intermediary model object. But ideally you are using the same JSON date format across all date properties in which case changing the format of the Date in the JSON is easy enough. `JSONEncoder` has a `dateEncodingStrategy` which [supports several formats](https://developer.apple.com/documentation/foundation/jsonencoder/dateencodingstrategy)\n\nJSONEncoder can be configured like so:\n\n```\nlet enc = JSONEncoder()\n    enc.outputFormatting = [.prettyPrinted , .sortedKeys]\n\n    //Like this\n    enc.dateEncodingStrategy = .iso8601\n\n    //OR this\n    enc.dateEncodingStrategy = .secondsSince1970\n\n    //or this (but not really)\n    let sillyFormatter = DateFormatter()\n    sillyFormatter.locale = Locale(identifier: \"en_US_POSIX\")\n    sillyFormatter.dateFormat = \"EEEE, MMM d, yyyy 'at' HH:mm\"\n    enc.dateEncodingStrategy = .formatted(sillyFormatter)\n```\n\nand would now give an output like so:\n\n```\n// Or\n{\n  \"name\" : \"Test Event\",\n  \"timestamp\" : \"2019-04-25T11:07:19Z\",\n  \"widgetCount\" : 10\n}\n\n// Or\n{\n  \"name\" : \"Test Event\",\n  \"timestamp\" : 1556190419.3267961,\n  \"widgetCount\" : 10\n}\n\n// Or\n{\n  \"name\" : \"Test Event\",\n  \"timestamp\" : \"Thursday, Apr 25, 2019 at 11:55\",\n  \"widgetCount\" : 10\n}\n```\n\nThe first example, iso8601 is pretty common (and what you should probably use if you control both client and server).\n\nThe second example is a unix epoch timestamp.\n\nThe 3rd example is a bit silly - it's extremely unlikely that an API server would be expecting dates formatted like this. But if you did need to customise the date string, that's the easiest way to do it.\n\n## Custom Formats\n\nBut focusing on the second example, the unix timestamp. A value of `1556190419.3267961` is a little unusual to me personally, as Iâ€™m not used to seeing the fractional component. To me, unix time stamps are integers. And some API designers out there seem to think the same. While some APIs do use this format, slacks API for example return timestamps like this - but some APIs may not like this.\n\nIf you have control over the API or can suggest changes ideally use this decimal format, it's more accurate. But if the API is out of your control, you may need to ensure it's an integer and not a decimal in your request, you can use a custom formatter like so:\n\n```\n    let enc = JSONEncoder()\n    enc.outputFormatting = [.prettyPrinted , .sortedKeys]\n\n    enc.dateEncodingStrategy = .custom({ date, encoder in\n        let seconds = Int(date.timeIntervalSince1970)\n        var singleValueEnc = encoder.singleValueContainer()\n        try singleValueEnc.encode(seconds)\n    })\n```\n\nwhich gives us:\n\n```\n{\n  \"name\" : \"Test Event\",\n  \"timestamp\" : 1556205171,\n  \"widgetCount\" : 10\n}\n```\n\nNow our integer assuming API won't be complaining.\n\nThis custom encoder approach would allow us to also represent dates as a completely different structure if needs be, without having to have our Event struct and all other model classes in our application being written using something other than the Date class:\n\n```\nfunc encodeDateAsObject(_ date: Date, _ encoder: Encoder) throws {\n\n    enum DateParts: CodingKey {\n        case year,month,day,hour,minute,second\n    }\n\n    var container = encoder.container(keyedBy: DateParts.self)\n\n    var cal = Calendar(identifier: .gregorian)\n    cal.locale = Locale(identifier: \"en_US_POSIX\")\n    cal.timeZone = TimeZone(identifier: \"UTC\")!\n\n    let dateComponents = cal.dateComponents([.year,.month,.day,.hour,.minute,.second], from: date)\n\n    try container.encode(dateComponents.year!, forKey: DateParts.year)\n    try container.encode(dateComponents.month!, forKey: DateParts.month)\n    try container.encode(dateComponents.day!, forKey: DateParts.day)\n    try container.encode(dateComponents.hour!, forKey: DateParts.hour)\n    try container.encode(dateComponents.minute!, forKey: DateParts.minute)\n    try container.encode(dateComponents.second!, forKey: DateParts.second)\n}\n\n// and then\n\n    let enc = JSONEncoder()\n    enc.outputFormatting = [.prettyPrinted , .sortedKeys]\n    enc.dateEncodingStrategy = .custom(encodeDateAsObject)\n```\n\nThis results in the following output being used for our API, while our `Event` struct continues to keep its property defined as `timestamp: Date` :\n\n```\n{\n  \"name\" : \"Test Event\",\n  \"timestamp\" : {\n    \"day\" : 25,\n    \"hour\" : 15,\n    \"minute\" : 22,\n    \"month\" : 4,\n    \"second\" : 48,\n    \"year\" : 2019\n  },\n  \"widgetCount\" : 10\n}\n```\n\n## Default Locale Issues\n\nAs an aside, it's worth noting the use of `en_US_POSIX` as a locale for the formatter in the examples above. There's a good chance the API server is expecting timestamps to be in UTC time rather than a specific local time, and also expects 24hr time, Gregorian calendar, etc.\n\nIf the locale is left as a default, behaviour might not be as expected depending on device settings. The lack of a fixed, server-specific locale when encoding data for APIs or decoding data from APIs is a common cause of issues we've encountered in the past. And if you are developing code in a location like Ireland where most people use 24hr clocks and are in UTC time zone for half the year it's very easy to slip by unnoticed.\n\nApple have a tech note specifically about this: [https://developer.apple.com/library/archive/qa/qa1480/\\_index.html](https://developer.apple.com/library/archive/qa/qa1480/_index.html)\n\nThis applies only to formats for communication between machines like a phone and a remote API server. For displaying dates to the user, you are usually best served by using the users default locale.\n\n## Other Resources\n\nFor other resources on date formatting & Swift codables, see:\n\n- https://nsdateformatter.com/\n- https://developer.apple.com/documentation/foundation/archives\\_and\\_serialization/encoding\\_and\\_decoding\\_custom\\_types\n- https://www.swiftbysundell.com/basics/codable\n- https://developer.apple.com/library/archive/qa/qa1480/\\_index.html\n\nJason Connery\n","postImage":"https://2upm2b1wdft320vzjj34rpga-wpengine.netdna-ssl.com/wp-content/uploads/2019/05/apple-black-and-white-black-and-white-169573.jpg.webp","categories":["development"],"tags":["ios","swift"]}},"__N_SSG":true}